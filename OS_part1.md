## ✔️ OS Thread vs Process
> 💡 프로세스와 스레드의 차이?
✅ 프로세스 : 운영체제로부터 자원을 할당받은 **작업의 단위**
✅ 스레드 : 프로세스가 할당받은 자원을 이용하는 **실행 흐름의 단위**

### 프로세스(Process)
▪️ 프로세스(Process)는 쉽게 말해 '**실행 중인 프로그램**'이다. 더 정확히 말하면, 디스크에 있는 프로그램이 메모리에 로드되면 프로세스가 된다. 하나의 프로그램이 여러 프로세스가 될 수 있다.

#### 특징
▪️ 각 프로세스는 별도의 주소 공간에서 실행되고 **프로세스끼리는 자원을 공유하지 않는다**.
▪️ 프로세스 내부에는 **최소 하나의 스레드(thread)** 를 가지고 있는데, 실제로는 스레드(thread) 단위로 스케줄링을 한다.
▪️ 한 프로세스가 다른 프로세스의 자원에 접근하려면 프로세스 간의 통신(IPC)을 사용해야 한다. 

> 📌 IPC
: Inter-Process Communication
프로세스들 사이 서로 데이터를 주고받는 행위 또는 그에 대한 방법이나 경로로 파이프, 파일, 소켓 등을 이용한 통신 방법이 있다.

▪️ 프로세스는 스택(Stack), 힙(Heap), 데이터(Data), 코드(Code)로 나뉜다. 
> **Stack** 영역 : 함수의 매개변수, 복귀 주소와 지역 변수와 같은 임시 자료를 위한 영역
**Data** 영역 : 전역 변수, static 변수 할당
**Heap** 영역 : 프로세스 실행 중에 동적으로 할당되는 메모리 영역
	- C언어 : malloc & free 
    - C++ : new & delete 
    - JAVA : new & (java에서 메모리 해제는 가비지컬렉터가 해줌)
**Code** 영역 : 프로그램을 실행시키는 실행 파일 내의 명령어 올라감
(쉽게 말하면 소스코드가 올라간다고 생각하면 됨)

![25](https://user-images.githubusercontent.com/60287901/208283145-52d7474b-4de4-4f68-9649-9d4cc0dacd20.png)



### 프로세스 제어 블록(Process Control Block, PCB)

▪️ PCB(Process Control Block)는 운영체제가 각 프로세스를 관리하기 위해 프로세스 별로 보유하고 있는 정보 묶음이다. 프로세스는 CPU를 할당받아 작업을 처리하다가도 프로세스 전환(문맥교환) 이 발생하면 진행하던 작업을 저장하고 CPU를 반환해야 하는데 이때 작업의 진행상황을 모두 PCB에 저장한다. 그리고 다시 CPU를 할당받게 되면 PCB에 저장되어있던 내용을 불러와 이전에 종료됐던 시점부터 다시 작업을 수행한다.

▪️ OS는 빠르게 PCB에 접근하기 위해 프로세스 테이블을 사용해 각 프로세스의 PCB를 관리한다.

▪️ PCB는 커널의 주소 공간에 있으며 다음의 구성 요소를 갖는다. 

1. 운영체제가 관리상 사용하는 정보
 - Process state : new, ready, running, waiting, terminated 등의 상태저장
 - Process ID : 프로세스 식별번호
 - Scheduling information : 프로세스의 중요도, 스케줄링 큐 포인터 등 스케줄링 파라미터 정보
 - Priority : 프로세스의 우선순위
 
2. CPU 수행 관련 하드웨어 값
 - Program counter : 해당 프로세스가 이어서 실행해야 할 명령의 주소를 가리키는 포인터
 - Register : 프로세스가 인터럽트 이후 올바르게 작업을 이어가기 위해 참조하는 CPU 레지스터 값
 
3. 메모리 관련
 - Code, Data, Stack의 위치 정보, base/limit 레지스터 값

4. 파일 관련
 - open file descriptors : 열린 파일 목록
![26](https://user-images.githubusercontent.com/60287901/208283154-e143fa6b-eca2-4f08-a67c-90811d5df833.png)



### 스레드(Thread)
▪️ 스레드(Thread)는 프로세스 내에서 실행되는 여러 **흐름의 단위**로, 프로세스의 특정한 수행 경로이다.

▪️ 프로세스 하나만을 사용해서 프로그램을 실행하기에는 메모리의 낭비가 발생한다. 메모리 낭비를 줄이고자 스레드는 프로세스와 다르게 **스레드 간 메모리를 공유**하며 작동한다.
▪️ 스레드는 프로세스 내에서 각각 Stack만 따로 할당받고 Code, Data, Heap 영역은 공유(=task)한다.
![27](https://user-images.githubusercontent.com/60287901/208283157-a87a38e2-dc71-40aa-9de5-0b6aab8309d7.png)

> 📌  스택을 스레드마다 할당하는 이유 ?
스택은 함수 호출 시 전달되는 인자, 되돌아갈 주소값 및 함수 내에서 선언하는 변수 등을 저장하기 위해 사용되는 메모리 공간이므로 스택 메모리 공간이 독립적이라는 것은 독립적인 함수 호출이 가능하다는 것이고 이는 독립적인 실행 흐름이 추가되는 것이다. 따라서 스레드의 정의에 따라 독립적인 실행 흐름을 추가하기 위한 최소 조건으로 독립된 스택을 할당한다.

▪️ 따라서 각각의 스레드는 별도의 레지스터와 program counter, 스택을 갖고 있지만, 힙 메모리는 서로 읽고 쓸 수 있다.
▪️ 한 스레드가 프로세스 자원을 변경하면, 다른 이웃 스레드(sibling thread)도 그 변경 결과를 즉시 볼 수 있다.


## Multi Process vs Multi Threading
### Multi Process
하나의 응용프로그램을 여러 개의 프로세스로 구성하여 각 프로세스가 하나의 작업(task)을 처리하도록 하는 것

**장점**
여러개의 자식 프로세스 중 하나에 문제가 발생하면 그 자식 프로세스만 죽고 다른 것에 영향을 미치지 않는다.

**단점**
✅ Context Switching에서의 오버헤드

- 이 과정에서 캐시 메모리 초기화 등 무거운 작업이 진행되고 많은 시간이 소모되는 등의 오버헤드가 발생한다.
- 프로세스는 각각의 독립된 메모리 영역을 할당받았기 때문에 프로세스 사이 공유하는 메모리가 없어, Context Switching이 발생하면 캐시에 있는 모든 데이터를 모두 리셋하고 다시 캐시 정보를 불러와야 한다.

✅ 프로세스 사이 어렵고 복잡한 통신 기법(IPC)
- 프로세스는 각각의 독립된 메모리 영역을 할당받았기 때문에 하나의 프로그램에 속하는 프로세스들 사이의 변수를 공유할 수 없다.

### Multi Threading
하나의 응용 프로그램을 여러 개의 스레드로 구성하고 각 스레드로 하여금 하나의 작업을 처리하는 것으로, 웹 서버가 대표적인 멀티 스레드 응용 프로그램이다.

**장점**
✅ 시스템 자원 소모 감소 (자원의 효율성 증대)
- 프로세스를 생성해 자원을 할당하는 시스템 콜이 감소해 자원을 효율적으로 관리

✅시스템 처리량 증가 (처리 비용 감소)
- 스레드 간 데이터를 주고 받는 것이 간단해지고 시스템 자원 소모 감소
- 스레드 사이 작업량이 작아 Context Switching이 빠름

✅ 간단한 통신 방법으로 인한 프로그램 응답 시간 단축
- 스레드는 프로세스 내 stack 영역을 제외한 모든 메모리를 공유하기 때문에 통신의 부담이 적음

**단점**
▪️ 주의깊은 설계가 필요
▪️ 디버깅 까다로움
▪️ 단일 프로세스 시스템의 경우 효과를 기대하기 어려움
▪️ 다른 프로세스에서 스레드를 제어할 수 없음 (즉, 프로세스 밖에서 스레드를 각각 제어할 수 없음)
▪️ 멀티 스레드의 경우 자원 공유의 문제 발생 (동기화 문제)
▪️ 하나의 스레드에 문제가 발생하면 전체 프로세스가 영향을 받음

> 📌 동기화 문제란 ? (Synchronization Issue)
멀티스레드를 사용하면 각각의 스레드 중 어떤 것이 어떤 순서로 실행될지 그 순서를 알 수 없다. 만약 A 스레드가 어떤 자원을 사용하다가 B 스레드로 제어권이 넘어간 후 B 스레드가 해당 자원을 수정했을 때, 다시 제어권을 받은 A가 해당 자원에 접근하지 못하거나, 바뀐 자원에 접근하게 되는 오류가 발생할 수 있다.
이처럼 **여러 스레드가 함께 전역 변수를 사용할 경우 발생할 수 있는 충돌**을 동기화 문제라고 한다.

## 스케줄러(Scheduler)
> 📍 한정적인 메모리를 여러 프로세스가 효율적으로 사용할 수 있도록 다음 실행 시간에 실행할 수 있는 프로세스를 선택하는 역할


수많은 Process/Thread 가 있고, 이를 수행할 CPU core/thread는 한정되어 있기 때문에, 우리는 Process/Thread를 어떻게 처리를 할지 Scheduling을 해야한다.
이러한 프로세스는 여러 State의 상태를 가지며 이에따라 다르게 Scheduling을 해야한다. 이를 위해 3가지 종류의 Queue가 존재한다.

### Scheduling Queue
▪️ Job Queue(batch queue) : 현재 시스템 안의 모든 프로세스의 집합
▪️ Ready Queue : 현재 메모리 내에 적재되어 있으며 ready 상태인 모든 프로세스의 집합
▪️ Device Queue : I/O 장치 사용을 대기하는 프로세스의 집합

![28](https://user-images.githubusercontent.com/60287901/208283174-c5debad1-3512-47ff-a10b-b4ba513e6ccd.png)


각각의 Queue에 프로세스들을 넣고 빼주는 스케줄러는 크게 세 가지 종류가 존재한다.

### **Scheduler**
#### ▪️ 장기 스케줄러(Long-term scheduler = Job Scheduler)
- 한정된 메모리에 많은 프로세스가 메모리로 올라올 경우, 대용량 메모리(디스크)에 임시로 저장되는데 여기서 어떤 프로세스에 메모리를 할당하여 ready queue로 옮길지 결정하는 역할을 수행한다.(new -> ready)

> ✅ 초, 분 단위로 비교적 가끔 호출되므로 속도가 느린 것이 허용된다.
✅ 메모리-디스크 사이의 스케쥴링을 담당하며
✅ 프로세스에 메모리 및 각종 자원을 할당한다.
✅ 메모리에 동시에 올라가 있는(실행 중인) 프로세스의 수를 조절한다.

- Unix, Microsoft Windows 등의 시분할 시스템에서는 장기 스케줄러가 사용되지 않는다!
💡현대의 운영체제에서는 프로세스가 시작되면 장기 스케줄러 없이 바로 그 프로세스에 메모리를 할당해 준비 큐에 넣어준다.

#### ▪️ 단기 스케줄러(Short-term scheduler = CPU Scheduler)
- 준비 상태의 프로세스 중에서 어떤 것을 실행 상태로 바꿀지 결정한느 스케줄러이다.(ready -> running -> waiting -> ready)
- 시분할 시스템에서는 타임 인터럽트로 인해 단기 스케줄러가 호출된다.
	 CPU-메모리 간의 스케줄링을 담당
	 스케줄링 알고리즘에 따라 해당 프로세스에 CPU를 할당한다.(Scheduler dispatch)
- 장기 스케줄러에 비해 실행 간격이 짧으며, 실행 빈도가 높다.

#### ▪️ 중기 스케줄러(Medium-term scheduler = Swapper)
- 메모리에 너무 많은 프로그램이 동시에 올라가는 것을 조절하는 스케줄러로, 메모리에 적재된 프로세스의 수를 조절한다.(ready->suspended)
    - 여유 공간 마련을 위해 프로세스를 통째로 메모리에서 디스크로 쫓아낸다.(**swap out**)
    - blocked 상태는 다른 I/O 작업을 기다리는 상태이기 때문에 스스로 ready state로 돌아갈 수 있지만 suspended 상태는 외부적인 이유로 넘어간 것이므로 스스로 돌아갈 수 없다.

> 📍 Swapping ?
✅ 장기 스케줄러와 마찬가지로 메모리에 올라와있는 프로세스의 수를 조절하는 역할을 한다.
✅ 만약 메모리에 많은 수의 프로세스가 적재되어 프로세스 당 보유하고 있는 메모리량이 극도로 적어지면 CPU 수행에 당장 필요한 프로세스의 주소 공간조차도 메모리에 올려놓기 어려운 상황이 발생한다.
✅ 이로인해 디스크 I/O가 수시로 발생하게 되어 시스템의 성능이 심각하게 저하될 수 있다.
✅ 가상 메모리 체제에서 너무 많은 프로세스가 적재되면 하드디스크 입출력이 과다해져서 시스템이 거의 멈추는 현상(Trashing, 메모리 영역에 접근할 때 메모리에 페이지 부재율이 높은 것을 의미함)이 발생한다.
✅ 이런 경우 메모리에 올라와 있는 프로세스 중 일부의 메모리를 통째로 빼앗아 디스크의 스왑 영역에 저장한다.(Swap Out) 이때, 스왑아웃의 대상은 suspended 상태에 놓인 프로세스가 1순위이다.
✅ suspended 프로세스를 swap out 했는데도 문제가 해결되지 않는다면 준비큐로 이동하는 프로세스를 추가적으로 swap out 시킨다.
✅ 메모리에 여유가 생기면 다시 swap in!

![29](https://user-images.githubusercontent.com/60287901/208283188-58b718ac-0644-458f-9e1b-3c35ae5bbaac.png)

>📍 CPU 스케줄링(Short-term Scheduler)
✅ 스케줄링 대상은 Ready Queue 에 있는 프로세스들이다.
✅ 선점/비선점 스케줄링으로 나뉜다.


### 비선점 스케줄링(Non-preemptive Scheduling)

▪️ 어떤 프로세스가 실행 상태에 들어가면 그 프로세스가 끝나거나 CPU를 자진 반납하는 경우가 아니면 계속 실행되는 상태를 의미한다.
▪️ Context switch에 대한 오버헤드가 없다.
- 일괄 처리 시스템에 적합하며 응답 시간 예측이 쉬운 장점이 있다.
- 짧은 작업이 긴 작업을 기다리는 경우 전체 시스템의 처리 효율 떨어진다.

#### FCFS 스케줄링(First-Come First-Served)
▪️ FIFO 스케줄링이라고도 하며 준비큐에 먼저 도착한 순서에 따라 CPU를 할당하는 스케줄링 기법
▪️ 먼저 들어온 프로세스가 먼저 처리되어 공평성은 유지되나, 중요한 작업(burst time이 짧은 작업)이 중요하지 않은 작업(긴 작업)을 기다릴 가능성이 있다. (Convoy Effect 라고 함)

#### SJF 스케줄링(Shortest Job First)
▪️ 실행 시간이 가장 짧은 프로세스에 먼저 CPU를 할당하는 스케줄링 기법
▪️ 프로세스들의 평균 대기 시간(Average waiting time)이 가장 짧다.
▪️ 기아 상태(Starvation)가 발생할 수 있다. 기아는 에이징으로 해결한다.
> 📍 Starvation ? Aging ?
✅ Starvation : 계속해서 우선순위가 높은 프로세스(burst time 짧은)가 먼저 실행되어 먼저 도착했어도 우선순위가 낮은 프로세스(burst time 긴)가 계속해서 CPU를 할당받지 못하는 현상
✅ Aging : 시스템에서 특정 프로세스의 우선순위가 낮아서 무한정 기다리는 경우를 방지하기 위해 기다린 시간에 비례해 일정 시간이 지나면 우선순위를 한 단계씩 높여주는 방법으로, 무한 연기 or starvation을 예방하기 위한 기법이다.
SJF + Aging -> HRN 기법

#### HRN 스케줄링(Highest Response Ratio Next)
▪️ SJF의 문제점을 보완한 스케줄링이다.
▪️ 실행시간과 대기 시간을 둘 다 고려해 우선순위를 정하고, 각 프로세스의 우선순위에 따라 CPU를 할당한다.
▪️ 우선순위 = (waiting time + burst time) / burst time

#### 우선순위 스케줄링
▪️ 각 프로세스마다 우선순위를 부여하고, 각 프로세스의 우선순위에 따라 CPU를 할당
▪️ 우선순위는 시간제한, 메모리 요구, 열린 파일의 수, 평균 실행 시간, 프로세스의 중요도, 자원 사용량을 복합적으로 고려하여 정한다.
▪️ Starvation 발생
📍 선점 스케줄링으로 구현하게 된다면 더 높은 우선순위의 프로세스가 도착했을 때 실행중인 프로세스를 멈추고 해당 프로세스가 CPU를 선점하게 된다.

### 선점 스케줄링(Preemptive Scheduling)

▪️ 어떤 프로세스가 사용 중인 CPU를 다른 프로세스가 강제로 빼앗을 수 있음
▪️ 시분할 시스템에 적합하며 응답 시간이 빠르다.
▪️ CPU를 선점할 프로세스에게 일정한 시간을 배정하기 위해 인터럽트용 타이머가 필요하다.
▪️ 비선점 스케줄링에 비해 context switch에 대한 오버헤드가 크다.

#### Round-Robin 스케줄링
▪️ 시분할 시스템을 위해 설계된 스케줄링으로, FCFS 스케줄링과 유사하며 선점이 가능하도록 시간 단위(Time Slice/Quantum) 개념이 추가되어 있다.
▪️ 준비 큐에 먼저 들어온 프로세스가 먼저 CPU를 할당받지만, 각 프로세스는 Time Slice만큼만 실행된 후 다시 준비 큐로 돌아간다.
▪️ Time Slice가 커지면 FCFS와 같아지고, Time Slice가 작아지면 Context Switch가 자주 발생하여 오버헤드가 커진다.

#### SRTF(Shortest Remaining Time First)
▪️ 새로운 프로세스가 도착할 때마다 새로운 스케줄링이 이루어진다.
▪️ 현재 수행중인 프로세스는 남은 burst time보다 더 짧은 CPU burst time을 가지는 새로운 프로세스가 도착하면 CPU를 뺏긴다.
▪️ starvation 발생
▪️ 새로운 프로세스가 도달할 때마다 스케줄링을 다시 하기 때문에 CPU 사용시간 측정 불가

#### MLQ(multi level Queue)
▪️ 프로세스들을 특정 그룹으로 분리하여, 각 그룹마다 Queue를 이용하여 스케줄링 하는 기법
▪️ 전면작업(Foreground Task, 우선순위 높음)와 후면작업(Background Task, 우선순위 낮음)로 프로세스를 분리한다. 이외에도 프로세스의 특성 및 종류에 따라 여러개로 나눈다.
▪️ 전면작업은 Round-Robin과 같이 효율적으로 빠르게 실행될 수 있는 기법을 적용하고 후면작업은 FIFO 기법으로 진행된다.
▪️ 하지만 한번 특정 큐에 들어가면 다른 큐로의 이동이 불가능하기 때문에 스케줄링에 대한 오버헤드가 낮다는 장점이 있으나 유연성이 떨어진다는 단점이 있다.

#### MLFQ(multi level Queue)
▪️ 다단계 큐 스케줄링의 유연성을 제공하는 방식이다. 
▪️ 프로세스는 우선순위가 다른 큐로 이동이 가능하다. (큐 사이의 프로세스 이동이 가능!)
▪️ IO Burst의 경우 우선순위가 높은 큐로 이동시키고, CPU Burst의 경우 낮은 우선순위 큐로 이동시키면서 프로세스 처리의 유연성을 높이는 것이다. 
▪️ Aging 등의 방식을 적용해서 대기 시간이 긴 프로세스도 높은 우선순위 큐에 올려서 기아 상태를 방지하는 장점을 얻을 수 있다. 
▪️ 하지만 큐의 수, 큐가 가지는 알고리즘, 우선순위 조절, 프로세스의 이동 등 관리의 복잡함이 증가된다.

### 동기 (Synchronous)
▪️ 요청과 그 결과가 동시에 일어나는 것. 요청 후 결과가 와야만이 그 다음 작업이 이루어지는 방식.

> ✅ 간단하고 직관적
✅ 어떠한 일을 처리하는 동안 다른 일을 하지 못함
✅ 작업 완료여부를 호출한 쪽에서 신경 씀

### 비동기 (Asynchronous)
▪️ 요청과 그 결과가 동시에 일어나지 않는 것. 요청 후 결과가 오는 동안 그 다음 작업이 이루어지는 방식.

>✅ 동기보다 복잡
✅ 어떠한 일을 처리하는 동안 다른 일을 할수 있어 자원을 효율적으로 사용
✅ 작업 완료여부를 호출된 쪽에서 신경 씀

![30](https://user-images.githubusercontent.com/60287901/208283205-94004d55-0168-4b7a-bfad-d9b12e0a4a4c.png)

