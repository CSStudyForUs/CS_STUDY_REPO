## Key의 개념 및 종류
> Key란, 검색 및 정렬 시 튜플(행)을 구분할 수 있는 기준이 되는 Attribute이다.

### 1. Candidate Key(후보키)

> 튜플을 유일하게 식별하기 위해 사용하는 속성들의 부분집합으로, 기본키로 사용할 수 있는 속성들을 말한다.

💡 **유일성**과 **최소성**의 2가지 조건을 만족해야 한다.
> - 유일성: 키로 하나의 튜플을 유일하게 식별할 수 있어야 한다.
- 최소성: 꼭 필요한 속성으로만 구성해야 한다.


### 2. Primary Key(기본키)
> 후보키 중 선택한 키를 의미한다.

💡 Not Null & No Duplicate _ 개체 무결성의 조건이기도 함

### 3. Alternate Key(대체키)
> 후보키 중 기본키를 제외한 나머지 키를 의미하며 보조키 라고도 한다.

### 4. Super Key(슈퍼키)
> 유일성은 만족하지만, 최소성은 만족하지 못하는 키

### 5. Foreign Key(외래키)
> 다른 릴레이션의 기본키를 그대로 참조하는 속성의 집합

💡 외래키로 지정되면 참조 테이블의 기본키에 없는 값은 입력할 수 없음. (참조 무결성 조건)


----
## Join

> 조인이란, 두 개 이상의 테이블이나 DB를 연결하여 데이터를 검색하는 방법으로
테이블을 연결하려면 적어도 **하나의 컬럼을 서로 공유**하고 있어야 하므로 이를 이용하여 데이터 검색에 활용한다.


### Join 종류

#### 1. Inner Join

![1](https://user-images.githubusercontent.com/60287901/201644130-2918c47c-497f-4735-a9ad-e831ef194b61.jpg)
```
< 암시적 조인 == Equi Join >
SELECT *

FROM EMPLOYEE, DEPARTMENT

WHERE EMPLOYEE.DepartmentID = DEPARTMENT.DepartmentID;
---
< 명시적 조인 >
SELECT *

FROM EMPLOYEE INNER JOIN DEPARTMENT

ON EMPLOYEE.DepartmentID = DEPARTMENT.DepartmentID;
```
![4](https://user-images.githubusercontent.com/60287901/201644285-8442c948-8a5f-4bb3-80e4-4668148d510b.png)
 
💡 Inner join 시, 비교 컬럼을 하나만 출력하고 싶다면 select절에서 테이블명.컬럼명 으로 출력하고자 하는 컬럼명 지정해주면 된다.

#### 2. Left Outer Join
![2](https://user-images.githubusercontent.com/60287901/201644385-fe9bd48b-8736-4955-96d3-44b2fca932ce.jpg)

#### 3. Right Outer Join
![3](https://user-images.githubusercontent.com/60287901/201644465-87fae083-796c-459d-ad87-f66cd44717d0.jpg)
💡 Outer Join 시, 조인 테이블(dept)에 데이터가 없어도 기준 테이블(emp)의 모든 데이터가 조회되고 조인 테이블(dept)에 데이터가 존재할 경우 해당 데이터를 참조할 수 있다.

#### 4. Full Outer Join
![5](https://user-images.githubusercontent.com/60287901/201644570-62027b2f-d8b5-4f90-925e-186efcd5eff7.png)
> LEFT OUTER JOIN과 RIGHT OUTER JOIN을 합친 것이다.
양쪽 모두 조건이 일치하지 않는 것들까지 모두 결합하여 출력한다.

💡Mysql에서는 Full Outer Join 키워드가 안되므로 Left Outer Join Union Right Outer Join을 통해 구현할 수 있다.

🙄: INNER JOIN OUTER JOIN의 차이가 무엇인가요? 그리고 LEFT JOIN, RIGHT JOIN, FULL JOIN은 또 무엇인가요?

A: 중복이 없는 서로 다른 두 컬럼을 JOIN한다고 가정했을 때, 
inner join을 A와 B에 대해 수행하는 것은, A와 B의 교집합을 구하는 것을 의미하며
outer join은 A와 B의 합집합을 의미합니다.
#### 5. Cross Join
```
SELECT *

FROM EMPLOYEE CROSS JOIN DEPARTMENT;
```
> 카티션 곱이라고도 하며 조인되는 두 테이블에서 곱집합을 반환함
-> A 테이블의 row: N개, B 테이블의 row: M개일때 총 N*M개의 row가 생성된다.

#### 6. Self Join
> 동일한 테이블을 조인하는 것으로, 자신이 갖고 있는 컬럼을 다양하게 변형시켜 활용할 때 주로 사용한다.
```
select F.empno, F.ename, S.empno, S.ename, S.job

from emp F inner join Emp S

on F.job = S.job

where F.empno < S.empno

order by F.empno, S.empno;
```

### SQL Injection
> 해커에 의해 조작된 SQL 쿼리문이 DB에 그대로 전달되어 비정상적인 명령을 실행시키는 공격 기법

#### 공격 방법

1) 인증 우회
보통 로그인을 할 때, 아이디와 비밀번호를 input 창에 입력하게 된다. 쉽게 이해하기 위해 가벼운 예를 들어보자. 아이디가 abc, 비밀번호가 만약 1234일 때 쿼리는 아래와 같은 방식으로 전송될 것이다.
```
SELECT * FROM USER WHERE ID = "abc" AND PASSWORD = "1234";
```
SQL Injection으로 공격할 때, input 창에 비밀번호를 입력함과 동시에 다른 쿼리문을 함께 입력하는 것이다.
```
1234; DELETE * USER FROM ID = "1";
```

이 밖에도 기본 쿼리문의 WHERE 절에 OR문을 추가하여 '1' = '1'과 같은 true문을 작성하여 무조건 적용되도록 수정한 뒤 DB를 마음대로 조작할 수도 있음.

2) 데이터 노출
시스템에서 발생하는** 에러 메시지를 이용해** 공격하는 방법이다. 
보통 에러는 버그 수정에 활용되는데, 해커들은 이를 역이용해 악의적인 구문을 삽입하여 에러를 유발시킨다.

즉, 해커는 GET 방식으로 동작하는 URL 쿼리 스트링을 추가하여 에러를 발생시킨다. 이에 해당하는 오류가 발생하면, 이를 통해 해당 웹앱의 데이터베이스 구조를 유추할 수 있고 해킹에 활용한다.

#### 방어 방법

🔒input 값을 받을 때, 특수문자 여부 검사하기
> 로그인 전, 검증 로직을 추가하여 미리 설정한 특수문자들이 들어왔을 때 요청을 막아낸다.

🔒SQL 서버 오류 발생 시, 해당하는 **에러 메시지 감추기**
> view를 활용하여 원본 데이터베이스 테이블에는 접근 권한을 높인다.(아무나 접근할 수 없게 한다.) **일반 사용자는 view로만 접근하여 에러를 볼 수 없도록 만든다.**

🔒Preparedstatement 이용하기
> **preparestatement를 사용**하면, 특수문자를 자동으로 escaping 해준다. (statement와는 다르게 쿼리문에서 전달인자 값을 ?로 받는 것) 이를 활용해 **서버 측에서 필터링 과정**을 통해서 공격을 방어한다.

## SQL과 NoSQL의 차이

### SQL(관계형 DB)

💡 관계형 데이터베이스에는 핵심적인 두가지 특징이 있다.

1. 데이터는 **정해진 데이터 스키마**에 따라 테이블에 저장된다.
	
    - 데이터는 테이블에 레코드로 저장되는데, 각 테이블마다 명확하게 정의된 구조(필드명과 데이터타입) 가 있다.
    - 따라서 스키마를 준수하지 않은 레코드는 테이블에 추가할 수 없다.

2. 데이터는 **관계**를 통해 여러 테이블에 분산된다.

	- 데이터의 **중복을 피하기 위해** 관계를 이용함
    - 하나의 테이블에서 중복 없이 하나의 데이터만을 관리하기 때문에 다른 테이블에서 부정확한 데이터를 다룰 위험이 없어진다는 장점이 있다.
    

### NoSQL(비관계형 DB)

💡관계형 DB와는 달리 스키마와 관계가 없다는 특징이 있다.

NoSQL에서는 레코드를 **문서(document)**라고 부른다.
문서는 JSON과 비슷한 형태로, 관계형 DB처럼 여러 테이블에 나누어 담는것이 아니라 관련 데이터를 동일한 컬렉션에 넣는다.

=> 조인이라는 개념이 존재하지 않는 이유!!

조인을 잘 사용하지 않고 자주 변경되지 않는 데이터일 때 NoSQL을 쓰면 상당히 효율적이다.

> 장점: 
- 데이터 분산, 대용량 데이터 처리에 특화되어 있으며 데이터에 대한 캐시가 필요한 경우에 적합하다. 또한, 배열 형식의 데이터를 고속으로 처리할 경우에 적합하다. 
- 데이터는 애플리케이션이 필요로 하는 형식으로 저장되므로 데이터 읽어오는 속도 빨라진다.
배열 형식의 데이터를 고속으로 처리할 경우에 적합하다. _ 이게 무슨 말인지 아시는 분
> 
단점:
- 유연성으로 인해 데이터 구조 결정을 미루게 될 수 있음
- 데이터 중복을 계속 업데이트 해야 함
- 데이터가 여러 컬렉션에 중복되어 있기 때문에 수정 시 모든 컬렉션에서 수행해야 함 (SQL에서는 중복 데이터가 없으므로 한번만 수행이 가능)


### 정리
![6](https://user-images.githubusercontent.com/60287901/201644795-47d5b641-c424-4956-bf1e-f8440bcd3e9e.png)

💡관계형 DB는 계층적 구조나 그래프 구조와 같은 데이터 모델을 저장하고 처리하기에는 적합하지 않지만, NoSQL은 다양한 데이터 모델링 기법을 통하여 해결할 수 있다. 
💡관계형 DB는 데이터 모델을 정의한 이후에 어플리케이션에 맞는 쿼리를 개발하지만 NoSQL은 어플리케이션에 필요한 쿼리와 성능을 정의한 이후에 요구사항에 부합하도록 데이터 모델을 구성한다는 차이가 있음

### 확장(Scaling)

- 수직적 확장(Scale-up): 단순히 DB 서버의 성능을 향상 시키는 것(CPU 업그레이드)
- 수평적 확장(Scale-out): 더 많은 서버가 추가되고 DB가 전체적으로 분산됨을 의미함(하나의 DB에서 작동하지만 여러 호스트에서 작동함)

그러나 데이터 저장방식으로 인해 **SQL DB는 일반적으로 수직적 확장만** 지원함
	- **NoSQL은 수평, 수직 확장 모두** 가능!!


### 데이터의 형식에 따라 SQL, NoSQL을 선택해야 한다.

#### SQL 사용이 적합한 경우
- 관계를 맺고 있는 데이터가 자주 변경되는 애플리케이션의 경우
- 변경될 여지가 없지만 명확한 스키마가 사용자와 데이터에 중요한 경우

#### NoSQL 사용이 적합한 경우

- 정확한 데이터 구조를 알 수 없거나 변경/확장 될 수 있는 경우
- 읽기를 자주 하지만, 데이터 변경은 자주 없는 경우
- 데이터베이스를 수평으로 확장해야 하는 경우 (막대한 양의 데이터를 다뤄야 하는 경우)


🙄 정규화를 해야하는 이유가 뭔가요?

A. 잘못된 테이블 설계로 인해 이상현상(Anomaly)이 발생하기 때문이다.

### 1. 삽입 이상
> 자료를 삽입할 때 의도하지 않은 자료까지 삽입해야만 자료를 테이블에 추가가 가능한 현상

ex) 기본키가 {Student ID, Course ID} 인 경우 -> Course를 수강하지 않은 학생은 Course ID가 없는 현상이 발생한다. 결국 Course ID를 Null로 할 수밖에 없는데, 기본키는 Null이 될 수 없으므로, Table에 추가될 수 없음!!

굳이 삽입하기 위해서는 '미수강'과 같은 _Course ID를 만들어야 함_.

**불필요한 데이터를 추가해야지, 삽입할 수 있는 상황 = Insertion Anomaly**

### 2. 갱신 이상 
> 중복된 데이터 중 일부만 수정되어 데이터 모순이 일어나는 현상

ex) 어떤 학생의 전공 (Department) 이 "컴퓨터에서 음악"으로 바뀌는 경우.

모든 Department를 "음악"으로 바꾸어야 함. 그러나 일부를 깜빡하고 바꾸지 못하는 경우, 제대로 파악 못함.

**일부만 변경하여, 데이터가 불일치 하는 모순의 문제 = Update Anomaly**

### 3. 삭제 이상 
> 어떤 정보를 삭제하면, 의도하지 않은 다른 정보까지 삭제되어버리는 현상

ex) 만약 어떤 학생이 수강을 철회하는 경우, {Student ID, Course ID, Department, Course ID, Grade}의 정보 중

Student ID, Department 와 같은 학생에 대한 정보도 함께 삭제됨.

**튜플 삭제로 인해 꼭 필요한 데이터까지 함께 삭제되는 문제 = Deletion Anomaly**

https://dev-coco.tistory.com/63

### DB Index
1. 목적: RDBMS에서 검색 속도를 높이기 위한 기술

- 테이블 내의 1개의 컬럼, 혹은 여러 개의 컬럼을 이용하여 생성될 수 있다
- RDB에서의 인덱스는 테이블 부분에 대한 하나의 사본으로 키-필드 값을 가지며 다른 세부 항목은 갖고있지 않다.
- 인덱스를 저장하는 데 필요한 디스크 공간은 보통 테이블을 저장하는 데 필요한 디스크 공간보다 작다. 
- 키-필드 형식으로 저장하기 때문에 중복된 항목이 등록되는 것을 금지한다 
	=> **고유성 보장**

> Table의 컬럼을 indexing함
-> 해당 테이블의 레코드를 Full Scan 하지 않음으로써 **B+ Tree 구조**로 Index 파일 검색이 가능해져 **검색 속도를 향상**시킨다.


2. 과정: 테이블을 생성하면 MYD, MYI, FRM 3개의 파일이 생성된다.
- FRM: 테이블 구조가 저장되어 있는 파일
- MYD: 실제 데이터가 있는 파일
- MYI: 인덱스 정보가 들어있는 파일

📎 인덱스를 사용하지 않는 경우, MYI 파일은 빈 상태이다. 
📎 인덱싱하는 경우 _MYI 파일이 생성되며_ 이후 사용자가 Select 쿼리로 **index를 사용하는 컬럼을 탐색 시, MYI 파일의 내용을 검색**한다. 

3. 단점

> 1. 인덱스 생성시, .mdb  파일 크기가 증가한다. 
2. 한페이지를 동시에 수정할 수 있는 병행성이 줄어든다.
3. 인덱스 된 필드에서 data를 업데이트하거나, 레코드를 추가 또는 삭제 시 성능이 떨어진다.
4. 데이터 변경 작업이 자주 일어나는 경우, index를 재작성해야 하므로, 성능에 영향을 미친다.

https://hongjuzzang.github.io/db/db_index/

4. 인덱스 관련 자료구조

📍 B-Tree(시간복잡도 O(logN))
-
- 일반적인 인덱스 구성 방법으로, 빠른 쿼리 동작과 검색을 위해 많은 양의 데이터를 저장하도록 설계된 자체 균형 트리 구조이다.
- 이진트리에서 발전되어 모든 리프노드들이 같은 레벨을 가질 수 있도록 자동 밸런스를 맞추는 트리이다. 
- B-Tree는 **노드에 여러 키-값**을 가질 수 있고, 키 순서에 따라 **오름차순**으로 저장된다.
- 키의 삽입과 삭제 시 Merge Sort가 발생할 수 있다.
- 

> 특징
📎 모든 노드는 최대 m개의 서브 노드를 가진다.
📎 루트 노드와 리프 노드를 제외한 모든 노드는 최소 m/2개, 최대 m개의 서브 노드를 가진다.
📎 노드의 자료 수가 k개라면 자식의 수는 k+1개여야 한다.
📎 모든 리프 노드는 같은 레벨에 나타나야 한다.
📎 한 노드안에 있는 키 값들은 오름차순을 유지한다.
📎 자료는 중복되면 안된다.

📍 B+Tree(시간복잡도 O(logN))
-
![18](https://user-images.githubusercontent.com/60287901/201645221-4fd71c54-a6e3-4d74-9fc6-854b1eeea0e3.png)

(주황색 노드는 index node, 초록색 노드는 data node)

- Index node: 리프 노드에 있는 키 값을 찾아갈 수 있는 라우터 역할(키만 있음)
- Data node: 리프 노드끼리 연결리스트로 형성되어있고 data를 가지고 있음

> 📎 루트 노드와 리프 노드를 제외한 모든 노드는 최소 m/2개, 최대 m개의 서브 노드를 가진다.
📎 루트 노드는 0 또는 2 ~m개의 서브 노드를 가진다.
📎 노드의 자료 수가 k개라면 자식의 수는  k+1개여야 한다.
📎 모든 리프 노드는 같은 레벨에 나타나야 한다.
📎  한 노드 안에 있는 키 값들은 오름차순 정렬되어 있다.
📎 Data node 내의 리프 노드들은 모두 링크로 연결되어 있다.


💡 비교
![19](https://user-images.githubusercontent.com/60287901/201645748-96f0c015-39d1-4496-a00f-ab5c302d6c21.png)


#### B-Tree vs B+Tree
- 리프 노드를 제외하고 데이터를 담지 않기 때문에 메모리 확보가 가능하다.
- 하나의 노드에 더 많은 키를 담을 수 있어서 트리의 높이는 낮아진다.(cache hit 높일 수 있음)
- 풀 스캔 시, B+Tree는 리프노드에 데이터가 모두 있기 때문에 한번 선형 탐색하면 되므로 B-Tree에 비해 속도가 빠르다

📍 Hash Index (시간복잡도 O(1))
-
![20](https://user-images.githubusercontent.com/60287901/201645584-83e3e45d-27c1-4621-8020-08e374052663.png)

- 디스크 기반의 대용량 테이블용으로는 사용하지 않으나, 메모리 기반의 테이블에 주로 구현되어 있다.
- 빠른 검색을 제공하지만 키값 자체가 변환되어 저장되기 때문에 범위를 검색하거나 원본값 기준으로 정렬 불가능하다.
- 동등 비교 검색에는 최적화돼 있지만 범위 검색, 정렬 결과 가져오는 목적으로는 사용 불가능하다.(B-Tree를 DB 자료구조로 사용하는 이유)
-  다중 컬럼으로 생성된 해시 인덱스에서도 모든 컬럼이 동등 조건으로 비교되는 경우에만 인덱스를 사용할 수 있다.

5. Clustered Index vs Non Clustered Index
[출처]

https://velog.io/@sweet_sumin/%ED%81%B4%EB%9F%AC%EC%8A%A4%ED%84%B0%EB%93%9C-%EC%9D%B8%EB%8D%B1%EC%8A%A4-Clustered-Index-%EB%84%8C-%ED%81%B4%EB%9F%AC%EC%8A%A4%ED%84%B0%EB%93%9C-%EC%9D%B8%EB%8D%B1%EC%8A%A4-Non-Clustered-Index 

6. 인덱스 단편화 & 인덱스 리빌딩
[출처]
https://bebeya.tistory.com/entry/MSSQL-%EC%9D%B8%EB%8D%B1%EC%8A%A4-%EB%8B%A8%ED%8E%B8%ED%99%94-%ED%99%95%EC%9D%B8-%EB%A6%AC%EB%B9%8C%EB%93%9C-%EC%A7%84%ED%96%89-100-%ED%9A%A8%EA%B3%BC 

https://datalibrary.tistory.com/128
https://velog.io/@sweet_sumin/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EC%9D%B8%EB%8D%B1%EC%8A%A4-%EB%A6%AC%EB%B9%8C%EB%93%9C%EA%B0%80-%ED%95%84%EC%9A%94%ED%95%9C-%EC%9D%B4%EC%9C%A0



---
- DBMS 의 인덱스는 **항상 정렬**된 상태를 유지하기 때문에 원하는 값을 **탐색하는데는 빠르지만** 새로운 값을 추가하거나 삭제, 수정하는 경우에는 쿼리문 실행 속도가 느려진다. 
- 결론적으로 DBMS 에서 인덱스는 **데이터의 저장 성능을 희생**하고 그 대신 데이터의 **읽기 속도를 높이**는 기능이다.

### DB 사용하는 이유
- DB가 존재하기 이전에는 파일 시스템을 이용하여 데이터를 관리하였는데,
- 파일 처리 시스템에서 데이터의 **종속성, 중복성**이 발생하였고 파일 관리 시스템에서 **중복성** 문제가 발생하여 이를 해결하기 위해 DB 등장했다.

> - 데이터 종속성(dependency): 응용 프로그램과 데이터가 상호 의존관계를 맺고 있는 것
→ 데이터의 구성 방법이나 접근 방법을 변경하면 관련된 응용 프로그램도 함께 변경해야 함
- 데이터 중복성(redundancy): 한 시스템 내에 같은 내용의 데이터가 여러 파일에 중복 저장된 것


### DB 특성

- 데이터 독립성

    - 논리적 독립성: DB는 논리적인 구조로 다양한 응용 프로그램의 논리적 요구를 만족시켜줄 수 있다.
    - 물리적 독립성: DB 사이즈나 성능 향상을 위해 데이터 파일을 늘리거나 새롭게 추가하더라도 관련된 응용 프로그램을 수정할 필요가 없다.
    
- 데이터 무결성: 여거 경로를 통해 잘못된 데이터가 발생하는 경우의 수를 방지하는 기능으로 데이터의 유효성 검사를 통해 무결성을 구현한다.

- 데이터 보안성: 인가된 사용자들만 DB나 DB 내의 자원에 접근할 수 있도록 설정함으로써 모든 데이터에 보안을 구현할 수 있다.

- 데이터 일관성: 연관된 정보를 논리적인 구조로 관리함으로써 어떤 하나의 데이터만 변경했을 경우 발생할 수 있는 데이터의 불일치성을 배제할 수 있다. 또한 작업 중 일부 데이터만 변경되어 나머지 데이터와 일치하지 않는 경우의 수를 배제할 수 있다.

- 데이터 중복 최소화: DB는 데이터를 통합해서 관리함으로써 파일 시스템의 단점 중 하나인 자료의 중복과 데이터의 중복 문제를 해결할 수 있다.


### DB 성능
데이터베이스의 성능 이슈는 **디스크 I/O 를 어떻게 줄이느냐에서 시작된다**. 디스크 I/O 란 디스크 드라이브의 플래터(원판)을 돌려서 읽어야 할 데이터가 저장된 위치로 디스크 헤더를 이동시킨 다음 데이터를 읽는 것을 의미한다. 이 때 데이터를 읽는데 걸리는 시간은 디스크 헤더를 움직여서 읽고 쓸 위치로 옮기는 단계에서 결정된다. **즉 디스크의 성능은 디스크 헤더의 위치 이동 없이 얼마나 많은 데이터를 한 번에 기록하느냐에 따라 결정된다고 볼 수 있다.**

그렇기 때문에 **순차 I/O** 가 랜덤 I/O 보다 빠를 수 밖에 없다. 하지만 현실에서는 대부분의 I/O 작업이 랜덤 I/O 이다. 랜덤 I/O 를 순차 I/O 로 바꿔서 실행할 수는 없을까? 이러한 생각에서부터 시작되는 **데이터베이스 쿼리 튜닝**은 **랜덤 I/O 자체를 줄여주는 것이 목적**이라고 할 수 있다.

### DB 쿼리 튜닝
https://velog.io/@gillog/SQL-%ED%8A%9C%EB%8B%9D

- SQL 튜닝이란, SQL문을 최적화하여 빠른 시간내에 원하는 결과값을 얻기 위한 작업

💡 튜닝 규칙
> 1. 가능하면 커서(Cursor)를 피하라.
2. 커서를 피할 수 없다면, 임시 테이블(temp table)을 사용하라
3. 임시 테이블을 현명하게 사용하라
4. 데이터를 미리 준비하라
5. 복합 뷰(Nested View)를 최소화하라
6. UPDATE 문 대신 CASE 문을 사용하라
7. 스칼라(Scalar) 대신 테이블 반환 함수(Table-Valued Functions)를 사용하라
8. SQL 서버에서 분할(Partition)을 활용하라
9. 배치 모드로 삭제(Delete)와 갱신(Update) 작업을 하라
10. 서두르지 말고 천천히 하라
11. ORM을 피하라
12. 가능한 경우, 저장 프로시저(Stored Procedure)를 사용하라
13. 더블 디핑(Double-Dipping: 중복 처리)을 피하라
14. 커다란 트랜잭션은 작은 트랜잭션 여러 개로 쪼개라
15. 트리거(Trigger) 사용을 자제하라
16. GUID(범용 고유 식별자)에 대한 클러스터링을 피하라
17. 테이블에 있는 모든 것을 카운트(Count)하지 말라
18. 행을 카운트하려면 시스템 테이블(System Table)을 사용하라
19. 필요한 수의 열만 끌어오라
20. 네거티브 검색(Negative Search)를 피하기 위해 쿼리를 재 작성하라
21. 맹목적으로 코드를 재사용하지 말라
22. 가급적 WHERE 조건에서는 인덱스 컬럼을 모두 사용한다.
23. 인덱스 컬럼에 사용하는 연산자는 가급적 동등 연산자(=)를 사용하라.
24. 인덱스 컬럼은 변형하여 사용하지 않도록 한다.
25. OR 보다는 AND를 사용해라.
26. 그룹핑 쿼리를 사용할 경우 가급적 HAVING 보다는 WHERE 절에서 데이터를 필터링하라.
27. DISTINCT는 가급적 사용하지 않는다.
28. IN, NOT IN 대신 EXISTS 와 NOT EXISTS를 사용하라
29. SET 연산자 사용시 UNION 대신 UNION ALL을 사용하라.
** 상세 내용은 본 글 링크 참고

### 목적

- 데이터의 **중복을 없애면**서 불필요한 데이터를 최소화시킨다.
- 무결성을 지키고, **이상 현상을 방지**한다.
- 테이블 구성을 논리적이고 직관적으로 할 수 있다.
- 데이터베이스 구조를 확장에 용이해진다.



📍제 1정규화(1NF)
-

- 테이블 컬럼이 **원자값(하나의 값)**을 갖도록 테이블을 분리시키는 것을 말한다.
- 기본키를 사용하여 관련 데이터의 각 집합을 고유하게 식별할 수 있어야 한다

📍제 2정규화(2NF)
-

- 테이블의 모든 컬럼이 완전 함수적 종속을 만족해야 한다.(**부분적 함수 종속 제거**)
	- 테이블에서 기본키가 복합키(키1, 키2)로 묶여있을 때, 두 키 중 하나의 키만으로 다른 컬럼을 결정지을 수 있으면 안된다. (= 기본키의 부분집합 키가 결정자가 되어선 안된다는 것)
   
📍제 3정규화(3NF)
-
  
- **2NF가 진행된** 테이블에서 **이행적 종속을 없애기 위해** 테이블을 분리하는 것이다.
** 이행적 종속 : A → B, B → C면 A → C가 성립된다.

📍BCNF 정규화
-

- 모든 **결정자**가 후보키 집합에 속해야 한다.
- 일반컬럼이 후보키를 결정하는 경우, 테이블을 분리함


### 정규화의 단점
> 릴레이션의 **분해로 인해 릴레이션 간의 연산(JOIN 연산)이 많아**진다. 이로 인해 질의에 대한 응답 시간이 느려질 수 있다. 조금 덧붙이자면, 정규화를 수행한다는 것은 데이터를 결정하는 결정자에 의해 함수적 종속을 가지고 있는 일반 속성을 의존자로 하여 입력/수정/삭제 이상을 제거하는 것이다. 데이터의 중복 속성을 제거하고 결정자에 의해 동일한 의미의 일반 속성이 하나의 테이블로 집약되므로 한 테이블의 데이터 용량이 최소화되는 효과가 있다. 따라서 _정규화된 테이블은 데이터를 처리할 때 속도가 빨라질 수도 있고 느려질 수도 있는 특성_이 있다.


### 역정규화

- 조회를 하는 SQL 문장에서 **조인이 많이 발생**하여 이로 인한 성능저하가 나타나는 경우에 반정규화를 적용하는 전략이 필요하다.

**[ 주의할 점 ]**
- 반정규화를 과도하게 적용하다 보면 **데이터의 무결성**이 깨질 수 있다. 
- 또한 입력, 수정, 삭제의 질의문에 대한 **응답 시간이 늦어질 수 있다.**

### 트랜잭션이란?
> 데이터베이스의 상태를 변화시키기 위해 수행하는 작업 단위로,작업의 완전성 을 보장해주는 것이다. 
즉, 논리적인 작업 셋을 모두 완벽하게 처리하거나(Commit) 또는 처리하지 못할 경우에는 (Rollback, savepoint) 원 상태로 복구해서 작업의 일부만 적용되는 현상이 발생하지 않게 만들어주는 기능이다. 사용자의 입장에서는 작업의 논리적 단위로 이해를 할 수 있고 시스템의 입장에서는 데이터들을 접근 또는 변경하는 프로그램의 단위가 된다.



#### 트랜잭션의 특징

- 원자성(Atomicity): 트랜잭션이 DB에 모두 반영되거나, 혹은 전혀 반영되지 않아야 된다.

- 일관성(Consistency): 트랜잭션의 작업 처리 결과는 항상 일관성 있어야 한다.

- 독립성(Isolation): 둘 이상의 트랜잭션이 동시에 병행 실행되고 있을 때, 어떤 트랜잭션도 다른 트랜잭션 연산에 끼어들 수 없다.

- 지속성(Durability): 트랜잭션이 성공적으로 완료되었으면, 결과는 영구적으로 반영되어야 한다.

#### 트랜잭션과 Lock(뭐가 다른데?!)

- 동시성을 제어하기 위해 Lock을 사용하며 여러 커넥션에서 동시에 동일한 자원(레코드나 테이블) 을 요청할 셩우 순서대로 한 시점에는 하나의 커넥션만 변경할 수 있게 해주는 역할을 한다.
- 논리적인 작업 셋 자체가 100% 적용 or 아무것도 적용되지 않아야 함을 보장하기 위해 트랜잭션을 사용한다.


#### 트랜잭션의 상태
![9](https://user-images.githubusercontent.com/60287901/201646158-1f039cf2-b5a5-42a0-beb2-da840112687e.png)
**Active**
트랜잭션의 활동 상태. 트랜잭션이 실행중이며 동작중인 상태를 말한다.

**Failed**
트랜잭션 실패 상태. 트랜잭션이 더이상 정상적으로 진행 할 수 없는 상태를 말한다.

**Partially Committed**
트랜잭션의 Commit 명령이 도착한 상태. 트랜잭션의 commit이전 sql문이 수행되고 commit만 남은 상태를 말한다.

**Committed**
트랜잭션 완료 상태. 트랜잭션이 정상적으로 완료된 상태를 말한다.

**Aborted**
트랜잭션이 취소 상태. 트랜잭션이 취소되고 트랜잭션 실행 이전 데이터로 돌아간 상태를 말한다.

> 🔒 Partially Committed 와 Committed 의 차이점
**Commit 요청이 들어오면 상태는 Partial Commited** 상태가 된다. 이후 Commit을 **문제없이 수행할 수 있으면 Committed 상태로 전이**되고, 만약 **오류가 발생하면 Failed** 상태가 된다. 즉, Partial Commited는 Commit 요청이 들어왔을때를 말하며, Commited는 Commit을 정상적으로 완료한 상태를 말한다.


- 트랜잭션은 꼭 필요한 최소의 코드에만 적용하는 것이 좋다. => 범위 최소화하기!
- 일반적으로 데이터베이스 커넥션은 개수가 제한적이다. 그런데 각 단위 프로그램이 커넥션을 소유하는 시간이 길어진다면 사용 가능한 여유 커넥션의 개수는 줄어들게 된다. 그러다 어느 순간에는 각 단위 프로그램에서 커넥션을 가져가기 위해 기다려야 하는 상황이 발생할 수도 있는 것이다.
### 트랜잭션 격리 수준(Transaction Isolation Level)

#### Isolation Level의 필요성
데이터베이스는 ACID 특징과 같이 트랜잭션이 독립적인 수행을 하도록 한다.

따라서 Locking을 통해, 트랜잭션이 DB를 다루는 동안 다른 트랜잭션이 관여하지 못하도록 막는 것이 필요하다.

하지만 _무조건 Locking으로 동시에 수행되는 수많은 트랜잭션들을 순서대로 처리하는 방식으로 구현하게 되면 데이터베이스의 성능은 떨어지게 될 것이다._

그렇다고 해서, 성능을 높이기 위해 Locking의 범위를 줄인다면, 잘못된 값이 처리될 문제가 발생하게 된다.

=> 효율적인 Locking이 필수!

#### Isolation Level 종류

1. Read Uncommitted(레벨 0)
	- Select 문장이 수행되는 동안 해당 데이터에 Shared Lock이 걸리지 않는 계층
    - 트랜잭션 처리중이거나 아직 commit되지 않은 데이터를 다른 트랜잭션이 읽는 것을 허용함
    	- 연산 이전 값을 읽을 수 있으므로 DB 일관성 유지가 불가능함**(Dirty Read 발생)**
        
2. Read Committed(레벨 1)
    ** 오라클 서버가 Default로 사용하는 계층임
	- SELECT 문장이 수행되는 동안 해당 데이터에 Shared Lock이 걸리는 계층
    - 트랜잭션이 수행되는 동안 다른 트랜잭션이 접근할 수 없어 대기하게 됨
    - Commit이 이루어진 트랜잭션만 조회 가능해짐
      - 하나의 트랜잭션 내에서 동일한 Select 쿼리를 실행했을 때 항상 같은 결과를 보장해야 한다는 Repeatable Read의 정합성에 어긋나게 됨**(NON-REPEATABLE READ 발생)**
    
3. Repeatable Read(레벨 2)
    	** MySql 서버가 Default로 사용하는 계층임
	- 트랜잭션이 완료될 때까지 SELECT 문장이 사용하는 모든 데이터에 Shared Lock이 걸리는 계층으로, 트랜잭션이 시작되기 전에 커밋된 내용에 관해서만 조회할 수 있는 격리 수준
    - 트랜잭션이 범위 내에서 조회한 데이터 내용이 항상 동일함을 보장함
    - 다른 사용자는 트랜잭션 영역에 해당되는 데이터에 대한 수정이 불가능하다.
    - 트랜잭션 도중 새로운 레코드 삽입이 일어나면 **Phantom Read 발생**
    	- 한 트랜잭션 안에서 일정 범위의 레코드를 두 번 이상 읽었을 때, 첫번째 쿼리에서 없던 레코드가 두번째 쿼리에서 나타나는 현상

4. Serializable(레벨 3)
	- 트랜잭션이 완료될 때까지 SELECT 문장이 사용하는 모든 데이터에 Shared Lock이 걸리는 계층으로, 한 트랜잭션을 다른 트랜잭션으로부터 완전히 분리하는 격리 수준(읽기 작업도 Shared Lock을 획득)
    - 완벽한 읽기 일관성 모드를 제공한다.
    - 다른 사용자는 트랜잭션 영역에 해당되는 데이터에 대한 수정 및 입력이 불가능하다.
    - 동시성이 중요한 데이터베이스에서는 거의 사용되지 않는다
    
> 🔒 동시성을 증가시키면 데이터 무결성에 문제가 발생하고, 데이터 무결성을 유지하면 동시성이 떨어지게 됨
🔒 레벨을 높게 조정할 수록 발생하는 비용이 증가하며 동시 처리 성능이 떨어짐

https://steady-coding.tistory.com/562 _ 트랜잭션 관련 질문 보기
### 교착상태(Deadlock)
- 두 개 이상의 트랜잭션이 특정 자원의 잠금(Lock)을 획득한 채 다른 트랜잭션이 소유하고 있는 잠금을 요구하면 아무리 기다려도 상황이 바뀌지 않는 상태가 되는데, 이를 교착상태라고 한다.


#### 교착 상태 빈도 낮추는 방법
- 트랜잭션을 자주 커밋한다.
- 정해진 순서로 테이블에 접근한다. 위에서 트랜잭션 1 이 테이블 B -> A 의 순으로 접근했고, 트랜잭션 2 는 테이블 A -> B의 순으로 접근했다. 트랜잭션들이 동일한 테이블 순으로 접근하게 한다.
- 읽기 잠금 획득 (SELECT ~ FOR UPDATE)의 사용을 피한다.
- 한 테이블의 복수 행을 복수의 연결에서 순서 없이 갱신하면 교착상태가 발생하기 쉽다. 이 경우에는 테이블 단위의 잠금을 획득해 갱신을 **직렬화** 하면 동시성은 떨어지지만 교착상태를 회피할 수 있다.

https://d2.naver.com/helloworld/407507 _ 트랜잭션 처리를 위한 DBMS의 대응 방식 관련 링크


자바에서 데이터베이스로 쿼리문을 전송할 때, 사용할 수 있는 인터페이스는 2가지가 존재한다.
Statement와 PreparedStatement이다.

둘 다 쿼리 전송 기능을 가지고 있지만
차이점이 존재하므로 어떤 차이점이 나는지, 어떤 인터페이스를 사용하는 것이 더 좋은지 알아보도록 한다.

### Statement
1) Statement 객체는 Statement 인터페이스를 구현한 객체를 Connection 클래스의 createStatement() 메소드를 호출함으로써 얻어진다.
2) Statement 객체가 생성되면 executeQuery() 메소드를 호출하여 SQL문을 실행시킬 수 있다.
메소드의 인수로 SQL문을 담은 Srting 객체를 전달한다.

3) Statement는 정적인 쿼리문을 처리할 수 있다.
즉, 쿼리문에 값이 미리 입력되어있어야한다.

### PreparedStatement
1) PreparedStatement 객체는 Connection 객체의 preparedStatement()메소드를 사용해서 생성한다. 이 메소드는 인수로 SQL문을 담은 String 객체가 필요하다.
2) SQL문장이 **미리 컴파일**되고, 실행 시간동안 인수 값을 위한 공간을 확보할 수 있다는 점에서 Statement 객체와 다르다.
3) Statement 객체의 SQL은 실행될 때, 매번 서버에서 분석해야하는 반면 PreparedStatement 객체는 한 번 분석되면 **재사용이 용이**하다.
4) 각각 인수에 대해 위치홀더(placeholder)를 사용하여 SQL문장을 정의할 수 있게 해준다.
위치 홀더는 **?** 로 표현된다.
5) 동일한 SQL문을 특정 값만 바꾸어서 여러번 실행해야 할 때, 인수가 많아서 SQL 문을 정리해야 될 필요가 있을 때 사용하면 유용하다.


### 🙄 Statement와 PreparedStatement의 가장 큰 차이점은?
```
캐시 사용 유무
```

1) statement : SQL문을 실행할 때마다 SQL을 매 번 구문을 새로 작성하고 해석해야하므로 오버헤드가 존재한다.
2) PreparedStatement : 선처리 방식 사용 (준비된 statement)
즉, SQL문을 미리 준비해 놓고 바인딩 변수(? 연산자)를 사용해서 반복되는 비슷한 SQL문을 쉽게 처리

> 쿼리 실행 순서
1. 쿼리 문장 분석
2. 컴파일
3. 실행

statement : 매번 쿼리를 수행할 때마다 1~3단계를 거친다.
PreparedStatement : 처음 한 번만 3단계를 거친 후 캐시에 담아 재 사용한다.


[출처]
https://velog.io/@dingdoooo/JDBC-Statement-PreparedStatement-%EC%9D%B4%EC%9A%A9%ED%95%98%EA%B8%B0

