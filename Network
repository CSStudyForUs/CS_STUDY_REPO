### HTTP의 GET, POST
둘 다 HTTP 프로토콜을 이용해서 서버에 무엇인가를 요청할 때 사용하는 방식이다.
📍 GET
-
- 요청하는 데이터가 Http Request Message의 Header 부분에 url이 담겨서 전송됨
- url 상에 ? 뒤에 데이터가 붙어 request를 보냄 => 전송할 수 있는 데이터의 크기가 제한적
    - 보안이 필요한 데이터(비밀번호)에 대해서는 데이터가 그대로 url에 노출되므로 적절하지 않음
```
www.example.com?id=mommoo&pass=1234 
// ?와 &가 구분자 역할을 해줌
// URI?key1=value1&key2=value2
```
- Body가 빈 상태로 전송되므로 헤더의 내용 중 body 데이터를 설명하는 **Content-Type**이라는 헤더필드는 들어가지 않는다.

📍 Post
-


- Http Request Message의 Body에 데이터가 담겨서 request가 전송됨
- **Content-Type**이라는 헤더필드가 들어가고 어떤 데이터 타입인지 명시한다.
> 💡 application/x-www-form-urlencoded // Default
💡 text/plain // text
💡 multipart/form-data // 파일 전송
- 데이터 크기가 Get 방식보다 크고, Get에 비해 상대적으로 보안이 나은 편이다.
	
    - POST든 GET이든 보내는 데이터는 전부 클라이언트측에서 볼 수 있다. 단지 GET방식은 URL에 데이터가 표시되여 별다른 노력없이 볼 수 있어서지, 두 방식 전부 보안을 생각한다면 암호화 해야한다.
    
> 🙄 둘이 뭐가 다른뎁쇼
A. Get은 Select적 성향을 갖고 있어서 서버에서 어떤 데이터를 가져와서 보여주는 용도이다. 반면, Post는 서버의 값이나 상태를 변경(추가)하기 위해서 사용된다.
  또한, Get 방식의 요청은 브라우저에서 캐싱할 수 있다. 따라서 Get 방식으로 요청한다면 기존에 캐싱되었던 데이터가 응답될 가능성이 존재한다.
  추가로, 캐싱이 기본인 Get은 Post보다 속도가 빠르다는 특징도 있다.

  


### TCP 3-way Handshake
3-Way Handshake 는 **TCP의 접속**,4-Way Handshake는 **TCP의 접속 해제 과정**이다.

- 포트(PORT) 상태 정보
	
    - LISTEN : 서버의 데몬이 떠서 접속 요청을 기다리는 상태
    - SYN-SENT : 로컬의 클라이언트 어플리케이션이 원격 호스트에 연결을 요청한 상태
    - SYN_RECEIVED : 서버가 원격 클라이언트로부터 접속 요구를 받아 클라이언트에게 응답을 하였지만 아직 클라이언트에게 확인 메시지는 받지 않은 상태
    - ESTABLISHED : 3 way-handshaking 이 완료된 후 서로 연결된 상태
    - FIN-WAIT1, CLOSE-WAIT, FIN-WAIT2 : 서버에서 연결을 종료하기 위해 클라이언트에게 종결을 요청하고 회신을 받아 종료하는 과정의 상태
    - TIME-WAIT : 연결은 종료되었지만 분실되었을지 모를 느린 세그먼트를 위해 당분간 소켓을 열어두고 있는 상태
    - CLOSING : 흔하지 않지만 주로 확인 메시지가 전송도중 분실된 상태 
    - CLOSED : 완전히 종료
    
- 플래그 정보
	
    - TCP Header에는 CONTROL BIT(6비트)가 존재하며, 각각의 bit는 "URG-ACK-PSH-RST-SYN-FIN"의 의미를 가진다.
    
    	- 즉, 해당 위치의 bit가 1이면 해당 패킷이 어떠한 내용을 담고 있는 패킷인지를 나타낸다.

- SYN(Synchronize Sequence Number) / 000010
💡 연결 설정. Sequence Number를 랜덤으로 설정하여 세션을 연결하는 데 사용하며, 초기에 Sequence Number를 전송한다.
- ACK(Acknowledgement) / 010000
💡 응답 확인. 패킷을 받았다는 것을 의미한다. ACK Number 필드가 유효한지 나타내며 양단 프로세스가 쉬지 않고 데이터를 전송한다고 가정하면 최초 연결 설정 과정에서 전송되는 첫번째 세그먼트를 제외한 모든 세그먼트의 ACK 비트는 1로 지정된다.
** 보낸 시퀀스 번호에 TCP 계층에서의 길이 또는 양을 더한 것과 같은 값을 ACK에 포함하여 전송 
- FIN(Finish) / 000001
💡 연결 해제. 세션 연결을 종료시킬 때 사용되며, 더 이상 전송할 데이터가 없음을 의미한다.

### 개념
> TCP 통신을 이용하여 데이터를 전송하기 위해 네트워크 연결을 설정(Connection Establish) 하는 과정
양쪽 모두 **데이터를 전송할 준비가 되었다는 것을 보장**하고, **실제로** 데이터 전달이 시작하기 전에 한 쪽이 다른 쪽이 준비되었다는 것을 **알 수 있도록 한다.**
즉, TCP/IP 프로토콜을 이용해서 통신을 하는 응용 프로그램이 데이터를 전송하기 전에 먼저 **정확한 전송을 보장**하기 위해 상대방 컴퓨터와 사전에 세션을 수립하는 과정을 의미한다.

#### 3-way handshake의 기본 매커니즘

TCP 통신은 PAR을 통해 신뢰적인 통신을 제공한다.

![10](https://user-images.githubusercontent.com/60287901/201647567-fe1fade7-851a-45ba-bf6a-16c966b90136.png)


💡 PAR을 사용하는 기기는 ack을 받을 때까지 데이터 유닛을 재전송한다!

- 수신자가 데이터 유닛(세그먼트)이 손상된 것을 확인하면(Error Detection에 사용되는 transport layer의 checksum을 활용), 해당 세그먼트를 없앤다. 그러면 sender는 **positive ack이 오지 않은 데이터 유닛을 다시 보내야한다.**

⇒ 이 과정에서 클라이언트와 서버 사이에서 **3개의 Segment가 교환되는 것**을 확인할 수 있다. 이것이 바로 3-way handshake의 기본 매커니즘이다.


### 작동방식

- Client는 서버와 연결하기 위해 3-way handshake를 통해 연결 요청을 한다.
	
    - Client, Server는 연결 요청을 누가 했느냐에 따라 정해진다. 요청을 먼저 보낸 쪽이 Client, 요청 받는 수신 측이 Server
- 
![11](https://user-images.githubusercontent.com/60287901/201647644-b6490eda-3c63-4340-a5c7-00f2ceee5c8b.png)


📍 Step 1(SYN)
클라이언트는 서버와 커넥션을 연결하기 위해 SYN을 보낸다. (seq : x)

> 송신자가 최초로 데이터를 전송할 때 swquence number를 임의의 랜덤 숫자로 지정하고, SYN 플래그 비트를 1로 설정한 세그먼트를 전송한다.

- PORT 상태
	Client : CLOSED- SYN_SENT 로 변함
	Server : LISTEN
    
📍 Step 2(SYN+ACK)
서버가 SYN을 받고, 클라이언트로 받았다는 신호인 ACK와 SYN 패킷을 보냄 (seq : y, ACK : x + 1)
	
> 1. 접속 요청을 받은 Server가 요청을 수락했으며 접속 요청 프로세스인 클라이언트도 포트를 열어달라는 메세지를 선종(SYN-ACK signal bits set)
2. ACK number 필드를 시퀀스넘버+1 로 지정하고 SYN과 ACK 플래그 비트를 1로 설정한 세그먼트 전송 (Seq=y, Ack=x+1, SYN, ACK)

- PORT 상태
  Client : CLOSED
  Server : SYN_RCV
  
📍 Step 3(ACK
클라이언트는 서버의 응답으로 ACK(x+1)와 SYN(y) 패킷을 받고, ACK(y+1)를 서버로 보냄

> 마지막으로 접속 요청 프로세스(클라이언트측)가 수락 확인을 보내 연결을 맺음
이때, 전송할 데이터가 있으면 이 단계에서 데이터 전송 가능하다.

- PORT 상태
  Client : ESTABLISED
  Server : SYN_RCV ⇒ ACK ⇒ ESTABLISED

#### Full-duplex 통신의 구성

Step 1, 2에서는 P→Q 방향에 대한 연결 파라미터(시퀀스 번호)를 설정하고 이를 승인한다.
Step 2, 3에서는 Q→P 방향에 대한 연결 파라미터(시퀀스 번호)를 설정하고 이를 승인한다.
⇒ 이를 통해 full-duplex 통신이 구축됨!


[참고]
https://velog.io/@averycode/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-TCPUDP%EC%99%80-3-Way-Handshake4-Way-Handshake

### TCP & UDP(4 layer)

📍UDP
-
![13](https://user-images.githubusercontent.com/60287901/201647954-6a58d6fa-9781-4206-a1b6-016941a02378.png)

UDP(User Datagram Protocol)는 **비연결형 프로토콜**이다. 즉, 데이터를 주고 받을 때 연결 절차를 거치지 않고 발신자가 일방적으로 데이터를 발신한다.
연결 과정이 없기 때문에 TCP에 비해 **신속성이 있지만** **신뢰성은 떨어진다.**
UDP는 데이터패킷을 순차적으로 보내더라도 이 패킷들은 서로 다른 통신 선로를 통해 전달될 수 있어 도착 순서 보장이 안된다.
(먼저 보낸 패킷이 느린 선로를 통해 전송될 경우 나중에 보낸 패킷보다 늦게 도착할 수 있으며 최악의 경우 유실 발생함. 이 경우 TCP와는 다르게 UDP는 중간에 패킷이 유실이나 변조되어도 재전송 하지 않는다.)

#### UDP 특징
- 데이터 경계를 구분한다.(데이터그램 서비스)
- 정보를 주고받을 때 정보를 보내거나 받는다는 신호절차를 거치지 않는다.
- 의미있는 서버를 구축하기 위해서는 일일이 패킷을 관리해줘야 한다.
- 패킷 오버헤드가 적어 네트워크 부하가 감소된다.
- VoIP, DNS

#### UDP 헤더 정보
![12](https://user-images.githubusercontent.com/60287901/201648043-d0b3e12c-413b-497c-8b82-79e59a166e91.png)

📍TCP
-

![14](https://user-images.githubusercontent.com/60287901/201648127-93d5e907-e8bf-46f4-aab7-e7326c723205.png)

TCP(Transmission Control Protocol)는 연결 지향적 프로토콜이다. 즉, 클라이언트와 서버가 연결된 상태에서 데이터를 주고받는 프로토콜을 의미하며 클라이언트가 연결 요청을 하고 서버가 연결을 수락하면 통신 선로가 고정되고, 모든 데이터는 고정된 통신선로를 통해 순차적으로 전달된다. 따라서 안정적이며 정확하게 데이터를 전달할 수 있다는 장점이 있다.
=> TCP 에서 연결 설정(connection establishment)는 3-way handshake를 통해 행해진다!!
주로 client와 Server 또는 P2P Socket 통신 등, 네트워크를 사용한 통신을 할 때 TCP 통신을 많이 사용한다.

#### TCP 특징

- 연결형 (connnection-oriented) 서비스로 연결이 성공해야 통신이 가능하다. _ 선연결 후전송
- 데이터의 경계를 구분하지 않는다. (바이트 스트림 서비스)
- 데이터의 전송 순서를 보장한다. (데이터의 순서 유지를 위해 각 바이트마다 번호를 부여)
- 신뢰성있는 데이터를 전송한다. (Sequence Number, Ack Number를 통한 신뢰성 보장)
- 데이터 흐름 제어(수신자 버퍼 오버플로우 방지) 및 혼잡 제어(패킷 수가 과도하게 증가하는 현상 방지) 
- 연결의 설정(3-way handshaking)과 해제(4-way handshaking)
- 전이중(Full-Duplex)// 전송이 양방향으로 동시에 일어날 수 있음, 점대점(Point to Point) 서비스// 각 연결이 정확히 2 개의 종단점을 가지고 있으며 1:1 통신만 가능함
- UDP보다 전송속도가 느리다.(특히, 고정 통신선로가 최단선이 아닐경우)
- **TCP 는 멀티캐스팅이나 브로드캐스팅을 지원하지 않는다.**

#### TCP 헤더 정보

![15](https://user-images.githubusercontent.com/60287901/201648200-16414966-cb68-41f4-afab-c705685b2d20.png)

![16](https://user-images.githubusercontent.com/60287901/201648280-33a75e50-dac9-4475-901c-8accc336d9f9.png)


#### 제어 비트 정보
![17](https://user-images.githubusercontent.com/60287901/201648338-a9d951f4-0d3d-443d-886f-b7c0c095a2a5.png)

[참고]
https://coding-factory.tistory.com/614

### HTTP의 문제점

- HTTP(80)는 평문 통신이기 때문에 도청이 가능하다.
- 통신 상대를 확인하지 않기 때문에 위장이 가능하다.
- 완전성을 증명할 수 없어 변조가 가능하다.

** 암호화하지 않는 프로토콜의 공통되는 문제점이기도 함.

---

**TCP/IP는 도청 가능한 네트워크이다. **

TCP/IP 구조의 통신은 전부 통신 경로 상에서 엿볼 수 있다. 패킷을 수집하는 것만으로 도청할 수 있다. 평문으로 통신을 할 경우 메시지의 의미를 파악할 수 있기 때문에 암호화하여 통신해야 한다.

**이를 보완하기 위해 **

1. SSL/TLS를 활용하여 통신 내용 자체를 암호화할 수 있다. 또한, SSL을 조합한 HTTP를 HTTPS(HTTP Secure) 혹은 HTTP over SSL이라고 부른다.
2. HTTP 메세지에 포함되는 콘텐츠를 암호화한다. 암호화해서 전송하면 받는 측에서 그 암호를 해독하여 출력하는 처리가 필요하다.

**통신 상대를 확인하지 않기 때문에 위장이 가능하다. **

HTTP 에 의한 통신에는 상대가 누구인지 확인하는 처리는 없기 때문에 누구든지 요청을 보낼 수 있다. IP 주소나 포트 등에서 그 웹 서버에 액세스 제한이 없는 경우 요청이 오면 상대가 누구든지 응답을 반환한다. 이러한 특징은 여러 문제점을 유발한다.
	
    1. 요청 보낸 곳의 웹 서버가 원래 의도한 응답을 보내야 하는 웹 서버인지를 확인할 수 없다.
    2. 응답을 반환한 곳의 클라이언트가 원래 의도한 요청을 보낸 클라이언트인지를 확인할 수 없다.
    3. 통신하고 있는 상대가 접근이 허가된 상대인지를 확인할 수 없다.
    4. 어디에서 누가 요청했는지 확인 불가
    4. 의미없는 요청도 수신한다 -> DoS 공격 방지할 수 없다.

**이를 보완하기 위해 **

위 암호화 방법으로 언급된 SSL로 상대를 확인할 수 있다. SSL은 상대를 확인하는 수단으로 증명서를 제공하고 있다. 증명서는 신뢰할 수 있는 제3자 기관에 의해 발행되는 것이기 때문에 서버나 클라이언트가 실재하는 사실을 증명한다. 이 증명서를 이용함으로써 통신 상대가 내가 통신하고자 하는 서버임을 나타내고 이용자는 개인 정보 누설 등의 위험성이 줄어들게 된다. 한 가지 이점을 더 꼽자면 클라이언트는 이 증명서로 본인 확인을 하고 웹 사이트 인증에서도 이용할 수 있다.

**완전성을 증명할 수 없어 변조가 가능하다. **

여기서 완전성이란 정보의 정확성을 의미한다. 서버 또는 클라이언트에서 수신한 내용이 송신측에서 보낸 내용과 일치한다라는 것을 보장할 수 없는 것이다. 리퀘스트나 리스폰스가 발신된 후에 상대가 수신하는 사이에 누군가에 의해 변조되더라도 이 사실을 알 수 없다. 이와 같이 공격자가 도중에 리퀘스트나 리스폰스를 빼앗아 변조하는 공격을 **중간자 공격**(Man-in-the-Middle)이라고 부른다.

**이를 보완하기 위해 **

**MD5, SHA-1** 등의 해시값을 확인하는 방법과 파일의 **디지털 서명**을 확인하는 방법이 존재하지만 확실히 확인할 수 있는 것은 아니다. **확실히 방지하기에는 HTTPS를 사용해야 한다.** SSL 에는 인증이나 암호화, 그리고 다이제스트 기능을 제공하고 있다.

### HTTPS

> HTTP Secure의 약어로, HTTP에 암호화와 인증, 그리고 완전성 보호를 더했다.

- HTTPS(443)는 SSL의 껍질을 덮어쓴 HTTP로, 새로운 계층의 프로토콜이 아닌 HTTP로 통신하는 소켓을 SSL/TLS로 대체한 것이다.
- HTTP - TCP 통신이 SSL - TCP로 바뀌게 됨
- HTTPS는 암호와, 증명서, 안전성 보호를 이용할 수 있음
- 대칭키 암호화, 공개키 암호화, 하이브리드 암호화 시스템 모두 사용함!!

**🔐 대칭키 암호화**
- 클라이언트오아 서버가 동일한 키를 이용해 암복호화를 진행함
- 키가 노출되면 매우 위험하나 연산속도 빠름


**🔐 공개키 암호화**
- 1개의 쌍으로 구성된 공개키와 개인키를 암복호화에 사용함
- 키가 노출되어도 비교적 안전하지만 연산 속도가 느림


#### 동작과정

HTTPS는 대칭키 암호화와 비대칭키 암호화를 모두 사용하여 빠른 연산 속도와 안정성을 모두 얻고 있다.

HTTPS 연결 과정(Hand-Shaking)에서는 먼저 서버와 클라이언트 간에 세션키를 교환한다. 여기서 **세션키**는 주고 받는 **데이터를 암호화**하기 위해 사용되는 대칭키이며, 데이터 간의 교환에는 **빠른 연산 속도**가 필요하므로 세션키는 **대칭키**로 만들어진다.
문제는 이 세션키를 클라이언트와 서버가 어떻게 교환할 것이냐 인데, 이 과정에서 비대칭키가 사용된다.

📍 즉, 처음 연결을 성립하여 안전하게 세션키를 공유하는 과정에서 비대칭키가 사용되는 것이고, 이후에 데이터를 교환하는 과정에서 빠른 연산 속도를 위해 대칭키가 사용되는 것이다.

[인증서를 통한 https 구현 과정은 다음 페이지 참고하기 ]
https://mangkyu.tistory.com/98

🙄 모든 웹 페이지에서 HTTPS를 사용해도 될까?
> 평문 통신에 비해서 **암호화 통신은 CPU나 메모리 등 리소스를 더 많이 요구**한다. 통신할 때마다 암호화를 하면 추가적인 리소스를 소비하기 때문에 서버 한 대당 처리할 수 있는 **리퀘스트의 수가 상대적으로 줄어들게 된다.**
**하지만** 최근에는 하드웨어의 발달로 인해 HTTPS를 사용하더라도 속도 저하가 거의 일어나지 않으며, 새로운 표준인 HTTP 2.0을 함께 이용한다면 오히려 HTTPS가 HTTP보다 **더 빠르게 동작**한다. 따라서 웹은 과거의 민감한 정보를 다룰 때만 HTTPS에 의한 암호화 통신을 사용하는 방식에서 **현재 모든 웹 페이지에서 HTTPS를 적용하는 방향으로 바뀌어가고 있다.**

🔔 별도의 소프트웨어 혹은 하드웨어 로드밸런싱 장비를 사용하지 않고, DNS만을 이용하여 도메인 레코드 정보를 조회하는 시점에서 트래픽을 분산하는 기법이다. 웹 뿐만아니라 도메인을 사용하는 모든 서비스-FTP, SMTP, TURN 등 -에서 사용이 가능하다.
>DNS(Domain Network System)란, 인터넷 주소창에 host domain name을 입력했을 때(naver, google) 해당 문자를 IP 주소로 변환해주는 시스템을 의미한다.
Local DNS Server란, Domain Name을 입력했을 때 해당 IP를 찾기 위해 가장 먼저 찾는 DNS 서버를 의미한다. IP를 찾는 역할을 하는 것은 Local DNS Resolver!
Root DNS Server란, 최상위 DNS 서버를 의미한다.


### DNSRoundRobin 원리
웹 서버로 예를 들자면, 웹 서비스를 담당할 **여러 대의 웹 서버는 자신의 공인 IP를 각각 가지고** 있다. 웹 사이트에 접속을 원하는 사용자가 해당 도메인 주소를 브라우저에 입력하면, DNS는 도메인의 정보를 조회하는데, 이때 IP 주소를 여러 대의 서버 IP 리스트 중에서 라운드 로빈 형태로 랜덤하게 하나 혹은 여러개를 선택하여 다시 사용자에게 알려준다.

결과적으로 웹 사이트에 접속하는 다수의 사용자는 실제로는 복수의 웹 서버에 나뉘어 접속하게 되면서 자연스럽게 서버의 부하가 분산되는 방식이다. 
![20](https://user-images.githubusercontent.com/60287901/201648678-28705dee-9985-47eb-a9ed-e22db4d4f06c.png)
** DNS Round Robin을 이용한 로드 밸런싱

DNS 조회 결과로 1개의 IP만 DNS 결과로 조회되는 경우도 있지만 최근의 DNS 라운드 로빈 방식은 복수의 IP를 모두 순서대로 제공하고 클라이언트로 하여금 선택하도록 한다.

### 🙄 그래서 언제 사용하는데? 단점은 뭐야?

DNS 라운드로빈 방식은 **지리적으로 복수의 웹 서버가 멀리 떨어져** 있어서 실시간으로 헬스 체크가 어려울 때 사용한다. +적은 비용으로 구현이 필요할 때도 사용함 !

일반적인 로드밸런싱은 뒤 단에 있는 백엔드 서버들의 헬스 체크 정보를 수반하지만, **DNS 라운드로빈은 로드밸런싱 기능이 없어서 별도의 헬스 체크가 없다.**
따라서 특정 웹 서버에 문제가 생겨 서비스가 불가한 상태라 하더라도 DNS는 이를 알 방법이 없고 해당 서버의 공인 IP를 도메인 조회 결과에 포함시키기 때문에 **고가용성이 떨어진다.** 이것이 라운드로빈 DNS의 최대 단점 !!

DNS 라운드 로빈은 여러 개의 IP 주소를 결과로 돌려주는데, 사용자의 운영 체제나 애플리케이션에 따라 동작이 다를 수 있다. 여러 개의 결과 IP 중, 제일 먼저 조회된 IP를 사용하는 경우도 있고 애플리케이션이 무작위로 하나 선택하여 접속할 수도 있다. 처음 선택한 IP가 접속이 안되면 그 다음으로 조회된 IP를 접속하도록 애플리케이션에 로직을 추가할 수도 있다.

#### DNS 조회 정보의 캐싱
조회된 IP 주소들은 사용자가 사용 중인 ISP의 로컬 DNS 로졸버에 캐싱이 되거나 사용자의 클라이언트 애플리케이션에도 캐싱이 될 수 있다.
캐싱 주기(TTL: Time to Live) 동안은 동일한 도메인에 대해서는 캐싱된 IP 주소를 사용한다.
> ISP(Intenet Service Provider)란, 개인이나 기업체에게 인터넷 접속 서비스, 웹사이트 구축 및 웹호스팅 서비스 등을 제공하는 회사를 말한다. 대표적으로 한국에서는 KT, SK브로드밴드, LG U+ 등이 있다.

✏️ 웹 페이지, 스트림 된 영상, 데이터베이스 쿼리 결과만 캐싱 하는 것이 아니라, DNS가 조회한 도메인의 IP 정보도 네트워크상에서 캐싱한다는 것을 잊지 말자.

따라서 도메인 설정 작업을 할 때엔 캐싱 주기를 고려해야한다. 캐싱을 무조건 길게 하면 관리자가 DNS 정보를 바꿔도 적용되기까지 상당한 시간이 걸리며 바뀐 DNS 정보가 인터넷상의 네임 서버에 전파(propagation)되는데 오랜 시간이 걸리기 때문이다. 반대로 주기가 너무 짧으면 빠른 업데이트 반영은 가능하지만, 도메인 조회가 빈번해지면서 사용자가 웹 사이트에 접속하는데 필요한 시간이 증가한다.


#### 최근 흐름
최근, 클라우드 벤더사들이 제공하는 라운드 로빈 DNS는 기존의 단점을 극복하기 위해 응답이 없는 웹 서버를 조회 결과에서 배제할 수 있도록 **자체적인 health check 로직을 추가**하고 있다. 그렇지만 이 경우에도 DNS 조회 결과가 캐싱된 시간만큼은 HA(고가용성) 구성이 어려운 단점은 여전히 남아있다. 따라서 대부분 CDN 업체들은 A 레코드의 **캐싱 주기를 매우 짧게** 가져가는 추세이다. 


#### 정리
> DNS Round Robin은 가용성을 제공하지 않기 때문에, 무중단 서비스가 필요한 시스템에는 어울리지 않으며 단순히 여러 대의 웹 서버로 트래픽을 부하 분산할 때 가장 편리하게 사용할 수 있는 옵션이다. 
가용성이 필요한 시스템의 경우, health check 기능이 포함된 DNS 서비스를 사용하는 것이 좋다. _Ex)Route53_
라운드 로빈 DNS의 단점을 보완하기 위해, GSLB(Global Server Load Balancing) DNS 서비스를 사용하여 DNS 조회 시, 로드 밸런싱과 동시에 health check 기능을 사용한 HA 구성이 모두 가능하도록 구성하는 것도 안전한 방법이다. 
로드밸런서 또한 SPOF(Single Point Of Failure)가 될 수 있으므로, 2대 이상의 로드밸런서와 각각의 공인 IP를 준비하고, GSLB로 트래픽을 로드밸런서에 나누는 방법도 많이 사용한다.
![21](https://user-images.githubusercontent.com/60287901/201648776-05bba4c7-bbc3-4c4c-bb90-602f2d95e9ec.png)


로그인 세션 등 세션의 유지 서버-클라이언트 간에 필요한 경우, 접속 중이던 클라이언트가 DNS에 의해 다른 서버 IP를 할당받아 다른 서버에 접속이 되면 기존 세션이 끊어질 수 있다. 이런 경우를 대비하여 웹 서버끼리 세션을 공유할 수 있도록 **세션 클러스터링** 설정을 하거나, **로드 밸런서에서 IP나 Cookie 값을 사용하여 동일한 서버로 접속되도록** stickness 설정을 해야 하는데, 이 부분은 **L7 스위치**로 해결할 수 있다.

---
**로드 밸런싱 알고리즘**
> - 라운드 로빈 방식 (Round Robin Method)
라운드 로빈 방식은 각 서버를 순차적으로 선택하여 요청을 분산시킵니다.
- 가중치 라운드 로빈 방식 (Weighted Round Robin Method)
각각의 서버에 가중치를 매기고, 가중치 비율에 따라 요청을 분산시킵니다. 주로 서버의 트래픽 처리 능력이 상이한 경우에 사용됩니다. 예를 들어 A 서버의 가중치가 7, B 서버의 가중치가 3이라면 A와 B로의 트래픽 분산 비율은 7:3이 됩니다.
- IP 해싱 방식 (IP Hash Method)
클라이언트의 IP 주소를 해시 처리하고, 특정 서버로 요청을 매핑하여 트래픽을 분배하는 방식입니다. 사용자의 IP 주소를 해시 처리하기 때문에 사용자가 항상 동일한 서버로 연결되는 것을 보장합니다.
- 최소 연결 방식 (Least Connections Method)
연결된 커넥션 수가 가장 적은 서버를 선택하여 요청을 분산시킵니다. 트래픽으로 인해 세션이 길어지는 경우에 권장하는 방식입니다.
- 최소 응답 시간 방식 (Least Response Time Method)
서버의 응답 시간이 가장 짧은 곳으로 트래픽을 분산시킵니다.
